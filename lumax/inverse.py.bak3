from typing import Callable, Tuple, Union

import numpy as np
import numpy.typing as npt
from scipy.optimize import root

from refmod.hapke import amsa
from refmod.hapke.amsa import amsa_derivative


def inverse_model(
    refl: npt.NDArray,
    incidence_direction: npt.NDArray,
    emission_direction: npt.NDArray,
    surface_orientation: npt.NDArray,
    phase_function: Callable[[npt.NDArray], npt.NDArray],
    b_n: npt.NDArray,
    a_n: npt.NDArray = np.empty(1) * np.nan,
    hs: float = 0,
    bs0: float = 0,
    roughness: float = 0,
    hc: float = 0,
    bc0: float = 0,
) -> Union[npt.NDArray, Tuple[npt.NDArray, npt.NDArray]]:
    refl = refl.flatten()
    mask = np.invert(np.isnan(refl))

    incidence_direction = incidence_direction.reshape(-1, 3)
    emission_direction = emission_direction.reshape(-1, 3)
    surface_orientation = surface_orientation.reshape(-1, 3)

    # refl_temp = (
    #     amsa(
    #         np.ones(surface_orientation.shape[0:2]),
    #         incidence_direction,
    #         emission_direction,
    #         surface_orientation,
    #         lambda x: phase_function(x),
    #         b_n,
    #         a_n,
    #         hs,
    #         bs0,
    #         roughness,
    #         hc,
    #         bc0,
    #     ),
    # )

    args = (
        incidence_direction[mask, :],
        emission_direction[mask, :],
        surface_orientation[mask, :],
        phase_function,
        b_n,
        a_n,
        hs,
        bs0,
        roughness,
        hc,
        bc0,
        refl[mask],
    )

    # albedo_recon = root(amsa, np.ones((1, refl.size)), args, method="krylov")
    albedo_recon = root(amsa, np.ones_like(refl), args, method="krylov")
    print(albedo_recon)
    # albedo_recon = leastsq(amsa, np.ones_like(refl.size), args)

    return albedo_recon
